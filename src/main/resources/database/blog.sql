/*
 Navicat Premium Data Transfer

 Source Server         : linovce
 Source Server Type    : MySQL
 Source Server Version : 80018
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80018
 File Encoding         : 65001

 Date: 26/05/2021 10:27:54
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `article_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '文章标识',
  `article_name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '文章名',
  `summary` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '摘要',
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '文章内容',
  `home_picture` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '首图路径',
  `labels` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '文章标签',
  `classifications` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '文章分类',
  `appreciate` int(11) NULL DEFAULT NULL COMMENT '点赞',
  `views` int(11) NULL DEFAULT NULL COMMENT '浏览量',
  `original` int(11) NULL DEFAULT NULL COMMENT '原创标记(1原创，0转载)',
  `is_comments` int(11) NULL DEFAULT NULL COMMENT '评论开启',
  `is_copyright` int(11) NULL DEFAULT NULL COMMENT '版权开启',
  `is_publish` int(11) NULL DEFAULT NULL COMMENT '是否发布',
  `create_date` date NULL DEFAULT NULL COMMENT '创建时间',
  `done_date` date NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`article_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (1, '对外API接口的安全性设计及鉴权方式', '一个公司需要拓展业务时，内部的业务系统往往需要跟外部系统交互，比如现在用户希望在支付宝或微信上交电费，话费，转账…那么电力公司、运营商、银行就需要跟支付宝和微信打通内部系统与支付宝微信系统之间的网络，提供相关api接口', '\n> 一个公司需要拓展业务时，内部的业务系统往往需要跟外部系统交互，比如现在用户希望在支付宝或微信上交电费，话费，转账......那么电力公司、运营商、银行就需要跟支付宝和微信打通内部系统与支付宝微信系统之间的网络，提供相关api接口。\n\n> 像这种对外的api接口往往对安全性有严格要求，本文整理了一下常用的api鉴权方式以及安全措施(如有不当之处，请路过的大佬指正)。\n\n\n## API鉴权方式\n\n> 直接把API暴露到互联网上给外部系统是存在安全风险的，因此我们要先对接口调用方做一个用户鉴权，对API权限划分，如果鉴权通过则允许用户调用API。根据不同的场景，鉴权方案也有很多种。\n### API Key + API Secret实现API鉴权\n这种方式是指当请求的资源、API Key 和 API Secret匹配时，用户才可以访问对应的资源，一般还会以时间戳等方式来进行请求的时效控制。\n\n**其原理为：** \n\n 1. 服务器给每个客户端生成一对Key/Secret保存，并告知客户端，Key和Secret之间没有任何关系，相互之间不能推算；\n 2. 发起请求时，会把包括API Key在内的所有的请求参数排序，然后跟API Secret一起做hash生成一个sign参数，服务器只需要按照约定的规则做一次签名计算，然后和请求的签名作比较，如果一致，则验证通过。\n\n为了避免重放攻击，可以加上时间戳参数，服务端验证时，如果时间超过允许范围则验证失败。\n\n需要注意的是，这种模式并不是RBAC，而是ACL访问权限控制。这种方式**实现简单，占用的计算资源和网络资源都较少，安全性也可以**。但是一般来说每一个api用户都需要分配一对Key和Secret，因此**当Key和Secret比较多的时候，服务器会有一定的存储成本** ，而服务端只能通过API Key来区别调用者，API Secret一旦泄密，将造成很大的安全风险。\n\n这种模式适用于大多是的Web API，除非需要在token中承载更多信息或者用户多到影响服务器部署。\n### Cookie + Session实现API鉴权\nCookie + Session是最传统的API鉴权方式，比如很多网站的登录模块就是靠这种方式实现会话管理。\n\n在服务端会生成一个session来保存会话状态，各个session是通过唯一的session_id来标识的，一次判断请求是哪个客户端发起，session_id存储在客户端的cookie中。\n\n后续的所有请求都会把cookie传到服务器端，服务器端解析cookie后找到对应的session进行判断。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021050810280777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTI0MTU3,size_16,color_FFFFFF,t_70)\n\n因此这种鉴权方式具有以下特点：\n\n 1. 为了使后台应用能识别是哪个用户发出的请求，需要在后台服务器存储一份用户登录信息(即session)，这份信息也会在响应前端请求时返回给前端，前端将其保存在cookie；\n 2. 下次请求时前端发送给后端应用，后端应用就可以识别这个请求是来自哪个用户；\n 3. cookie内仅包含一个session标识符而诸如用户信息、授权列表等都保存在服务端的session中。\n\n其优点是：\n\n 1. 比较传统，对开发来说资料较多，语言支持完善；\n 2. 较易于扩展，外部session存储方案已经非常成熟了（比如Redis）。\n\n但也有如下缺点：\n\n 1. **性能相于较低**：每一个用户经过后端应用认证之后，后端应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大；\n 2. 在一个无状态协议里注入了状态，**与REST风格不匹配**；\n 3. 因为基于cookie来进行用户识别, cookie如果被截获，用户就会很**容易受到CSRF攻击**；\n 4. **很难跨平台**：在移动应用上 session 和 cookie 很难行通，你无法与移动终端共享服务器创建的 session 和 cookie。\n\n总的来说，如果是传统的web网站，且同时认证的人数不是足够大（比如只是内部使用）的都可以用这种方式，很多网站依旧采用该方式。\n\n### token机制实现API鉴权\n\n> token令牌的机制是用来代替session的鉴权方式，现在很多api的鉴权都是通过token。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210509164921793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTI0MTU3,size_16,color_FFFFFF,t_70)\n\ntoken机制是服务器端生成的一串加密串发放给客户端，客户端请求服务器端所有资源时会带上这个Token，由服务器端来校验这个token的合法性。其具有无状态、适合分布式、扩展性好、性能高和安全性好等优点。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210509165433927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTI0MTU3,size_16,color_FFFFFF,t_70)\n\n常见的token实现有以下几种：\n\n - 自定义实现token：应用开发者根据token机制原理自行实现；\n - JWT：即Json Web Token，是一种主流的Token规范；\n - Oauth：Oauth虽然是授权规范，但其中也用到了Token；\n - HTTP Basic Authentication认证机制；\n - Web API是基于HTTP协议的，而HTTP协议本身就带有认证机制。\n## API接口的安全措施\n\n> 以上是博主总结的一些API鉴权方式。但是在调用API的过程中还需要保证数据在传输过程中的安全性、判断数据是否到达服务器以及服务器如何识别传到服务器的数据是否正确，如何不被攻击。\n\n### 数据加密\n数据在传输过程中是很容易被抓包的，如果直接传输，比如通过http协议，那么用户传输的数据可以被任何人获取，所以必须对数据加密。\n\n常见的做法对关键字段加密比如用户密码直接通过md5加密；现在主流的做法是使用https协议，在http和tcp之间添加一层加密层(SSL层)，这一层负责数据的加密和解密。\n\n现在主流的加密方式有对称加密和非对称加密。\n\n - **对称加密**：对称密钥在加密和解密的过程中使用的密钥是相同的，常见的对称加密算法有DES，AES，计算速度快，但是在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥，如果一方的秘钥被泄露，那么也容易泄密；\n - **非对称加密**：服务端会生成一对密钥，私钥存放在服务器端，公钥可以发布给任何人使用，优点就是比起对称加密更加安全，但是加解密的速度比对称加密慢太多了，广泛使用的是RSA算法。\n \n以上两种方式各有优缺点，而https的实现方式正好是结合了两种加密方式，整合了双方的优点，在安全和性能方面都比较好。\n### 数据签名\n数据在传输过程中经过加密，理论上就算被抓包，就无法对数据进行篡改；但是我们一般加密的部分其实只是在外网，现在很多服务在内网中都需要经过很多服务跳转，如果被攻入内网，则可以在任意节点篡改数据，所以这里的加数据签名可以防止内网中数据被篡改。\n\n数据签名就是由发送者产生一段无法伪造的一段数字串，来保证数据在传输过程中不被篡改。\n\nmd5算法是常用的数据签名算法，其原理是将需要提交的数据通过某种方式组合成一个字符串，然后通过md5算法生成一段加密字符串，这段加密字符串就是数据包的签名。为保证安全性，最后的密钥会在客户端和服务端各备一份。\n### 添加时间戳\n经过如上的加密，加签处理，就算拿到数据也不能看到真实的数据；但是有些攻击者不关心真实的数据，而是直接拿到抓取的数据包做恶意请求，以达到攻击的目的。\n\n我们可以使用时间戳机制，在每次请求的时候加入当前的时间，服务器端会拿到当前时间和消息中的时间相减，看看是否在一个固定的时间范围内，超过时间差的请求就视为非法请求。\n### 限流机制\n如果有用户出现频繁调用接口的情况；这种情况需要给相关用户做限流处理，常用的限流算法包括：令牌桶限流，漏桶限流，计数器限流。\n\n - **令牌桶限流**：系统以一定速率向桶中放入令牌，填满了就丢弃令牌；请求来时会先从桶中取出令牌，如果能取到令牌，则可以继续完成请求，否则等待或者拒绝服务。令牌桶允许一定程度突发流量，只要有令牌就可以处理，支持一次拿多个令牌；\n - **漏桶限流**：按照固定常量速率流出请求，流入请求速率任意，当请求数超过桶的容量时，新的请求等待或者拒绝服务，因此漏桶算法可以强制限制数据的传输速度；\n - **计数器限流**：这是一种比较简单粗暴的算法，主要用来限制总并发数，比如数据库连接池、线程池、秒杀的并发数；计数器限流只要一定时间内的总请求数超过设定的阀值则进行限流。\n### 黑名单机制\n如果此用户进行过很多非法操作，或者说专门有一个中黑系统，经过分析之后直接将此用户列入黑名单，所有请求直接返回错误码。\n\n我们可以给每个用户设置一个状态比如包括：初始化状态，正常状态，中黑状态，关闭状态等等；或者我们直接通过分布式配置中心，直接保存黑名单列表，每次检查是否在列表中即可。\n### 数据合法性校验\n这应该是每个系统都会有的处理机制，只有在数据是合法的情况下才会进行数据处理；每个系统都有自己的验证规则，当然也可能有一些常规性的规则，比如身份证长度和组成，电话号码长度和组成等等。合法性校验包括：常规性校验以及业务校验。\n\n - **常规性校验**：包括签名校验，必填校验，长度校验，类型校验，格式校验等；\n -  **业务校验**：根据实际业务而定，比如账户余额不能小于0等.\n## 总结\n本文大致列举了几种常见的API鉴权机制和安全措施，当然还有其他方式。但是我们除非为了学习，不然不建议为了用某种鉴权方式和安全措施或者用什么新技术新框架而强行使用，应该根据实际需要在这些机制的原理上做修改和组合，毕竟技术是为业务服务的。\n***\n> **如果觉得本文对你有帮助，可以对博主关注，如果平时不怎么看CSDN的关注人动态，可关注下面公众号，不定期分享一些小demo、小项目以及学习心得**。\n> \n> ![秀宇笔记](https://img-blog.csdnimg.cn/20210327111041466.jpg)\n\n**往期文章：**\n\n - [基于FreeMarker的自定义代码生成器](https://blog.csdn.net/qq_35524157/article/details/115260135)\n - [vue实现markdown编辑器以及md文件转化成html](https://blog.csdn.net/qq_35524157/article/details/114783950)\n - [使用Java生成思维导图](https://blog.csdn.net/qq_35524157/article/details/105882287)\n - [Java实现简易画图板](https://blog.csdn.net/qq_35524157/article/details/82832818)\n - [用Java实现平衡二叉树](https://blog.csdn.net/qq_35524157/article/details/105889182)\n', 'defaults', 'api,web设计,安全漏洞,Java,鉴权', '', 0, 57, 1, 1, 1, 1, '2021-04-07', '2021-04-07');
INSERT INTO `article` VALUES (2, '基于FreeMarker的自定义代码生成器', '我们平时开发一些项目时，可能需要创建很多代码，比如比如Web项目创建的bean，Mybatis项目创建的若干mapper接口文件和mapper映射文件。', '> 我们平时开发一些项目时，可能需要创建很多代码，比如比如Web项目创建的bean，Mybatis项目创建的若干mapper接口文件和mapper映射文件。\n\n> 在建立这些文件的过程中，我们可以发现，这些接口文件和映射文件从规则上来看基本上都是千篇一律。为此，官方以及民间大佬都提供了一些代码生成器，例如mybatis-generator、Mybatis-plus的代码生成器等，但是可能跟我们平时使用习惯不一样，比如mybatis-generator生成Example类来给数据库查询添加条件，但对于我这种强迫症来说，希望这个名字时Condition之类的描述而非Example。**本文将介绍如何使用FreeMarker定义自己的代码生成器**。\n\n# FreeMarker简介\nFreeMarker是一款模板引擎：即一种基于模板和要改变的数据，并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。[FreeMarker中文官网](http://freemarker.foofun.cn/index.html)。\n\n最基本的，我们需要有一个通用的**模板文件**、模板文件中需要个性化输出的**数据模型**，如下所示。\n**定义一个HTML模板：**\n```html\n<html>\n<head>\n  <title>Welcome!</title>\n</head>\n<body>\n  <h1>Welcome ${user}!</h1>\n  <p>Our latest product:\n  <a href=\"${latestProduct.url}\">${latestProduct.name}</a>!\n</body>\n</html>\n```\n\n其中\\${user}、\\${latestProduct.name}、\\${latestProduct.url}等内容就是根据提供的数据模型变化的动态部分。\n\n**定义一个数据模型：**\n数据模型的基本结构是树状的，这棵树可以很复杂，并且可以有很大的深度，我们通常通过Map类型的数据结构存储模型。\n```java\n(root)\n  |\n  +- user = \"Big Joe\"\n  |\n  +- latestProduct\n      |\n      +- url = \"products/greenmouse.html\"\n      |\n      +- name = \"green mouse\"\n```\n\n```java\n Map root = new HashMap();\n root.put(\"user\", \"Big Joe\");\n Map latest = new HashMap();\n root.put(\"latestProduct\", latest);\n latest.put(\"url\", \"products/greenmouse.html\");\n latest.put(\"name\", \"green mouse\");\n```\n模板和数据模型结合后，生成的HTML文件如下：\n\n```html\n<html>\n<head>\n  <title>Welcome!</title>\n</head>\n<body>\n  <h1>Welcome Big Joe!</h1>\n  <p>Our latest product:\n  <a href=\"products/greenmouse.html\">green mouse</a>!\n</body>\n</html>\n```\n关于如何通过Java将模板和模型整合到一起输出文件，以及FreeMarker的其他语法，大家可参考[FreeMarker中文官网](http://freemarker.foofun.cn/index.html)，这里不再赘述。\n# 使用FreeMarker生成JavaBean文件\n一个最基本的JavaBean文件示例：\n\n```java\npublic class Label{\n	\n	private Integer labelId;\n	private String labelName;\n	\n	public void setLabelId(Integer labelId){\n		this.labelId = labelId;\n	}\n	\n	public Integer getLabelId(){\n		return this.labelId;\n	}\n	public void setLabelName(String labelName){\n		this.labelName = labelName;\n	}\n	\n	public String getLabelName(){\n		return this.labelName;\n	}\n}\n```\n\n## 数据表列操作工具类ColumnUtil\n> 我们知道**数据表的表名、列名、列类型跟JavaBean中的名称和类型是有所差别的**，但也有规律可循，我们可以定义工具类ColumnUtil将数据库名称、类型信息转化成符合Java的变量名和变量类型。\n\n我们先定义两个静态数组，分别表示数据库中常用的列类型和JavaBean变量类型。\n```java\n//数据库中常用的列类型\nprivate static String[] fieldTypes = {\"tinyint\", \"int\", \"bigint\", \"varchar\", \"text\", \"date\", \"datetime\", \"decimal\",\"char\"};\n//对应的JavaBean变量类型\nprivate static String[] javaTypes = {\"Integer\", \"Integer\", \"Long\", \"String\", \"String\", \"java.util.Date\", \"java.util.Date\", \"Long\", \"String\"};\n```\n然后定义一些方法将两者对应起来，这个简单，这里不赘述。\n\n接下来就是列名和表名转化成符合Java规范的格式了，数据库中我们命名往往采用\"_\"分割，而Java中往往采用驼峰的形式，以下是将表名转化成符合Java规范的示例。\n```java\n//例如：TEST_JAVA_BEAN表转化成表名TestJavaBean类\npublic static String getClassName(String tableName){\n	String tempTableName = tableName.toLowerCase();\n	String[] tempNames = tempTableName.split(\"_\");\n	StringBuilder sbud = new StringBuilder();\n	for(int i = 0; i < tempNames.length; i ++){\n		sbud.append(tempNames[i].substring(0, 1).toUpperCase()).append(tempNames[i].substring(1));\n	}\n	return sbud.toString();\n}	\n```\n数据表列名转化同理，但需要注意类名是从第一个单词开始大写，变量是从第二个开始大写，因此有细微差别。\n\n获取列名对应的变量之后，再写两个方法定义setter/getter方法。\n\n```java\npublic static String getMethodName(String attrName){\n	return \"get\" + attrName.substring(0, 1).toUpperCase() + attrName.substring(1);\n}\n	\npublic static String setMethodName(String attrName){\n	return \"set\" + attrName.substring(0, 1).toUpperCase() + attrName.substring(1);\n}\n```\n## 数据表列操作工具类ColumnUtil\n\n> 一个数据库有多张表，一张表也有多个数据列，将数据库内容和Java内容对应之后，我们还得将表信息和列信息存储起来。\n\n我们需要定义一个ColumnInfo存储列信息，定义一个TableInfo来存储表信息，这都非常简单。\n\n```java\npublic class ColumnInfo {\n	\n	private String fieldName;//列名\n	\n	private String fieldType;//列类型\n	\n	private String javaType;//Java类型\n	\n	private String getMethodName;//对应getter方法\n	\n	private String setMethodName;//对应setter方法\n\n	private String comments;//表注释\n	\n	private boolean isKey;//是否主键\n}\n//省略setter/getter方法\n```\n```java\npublic class TableInfo {\n    private String tableName;//表名\n    private List<ColumnInfo> columnInfos;//列信息\n    //省略setter/getter方法\n}\n```\n\n## JavaBean模板\n从开头示例我们可以找出哪些是写死在模板中，哪些是需要通过数据模型获取的内容。\n\n - 类名——数据库的表名\n - 成员变量、setter/getter方法——数据表的列名\n - 变量类型、setter/getter方法返回类型——数据表各列的类型\n\n**根据以上分析，我们可以得到以下JavaBean模板：**\n```java\npackage ${modelPackage};\n\npublic class ${className}{\n	\n	<#list columns as column>\n	private ${column.javaType} ${column.attrName};\n	</#list>\n	\n	<#list columns as column>\n	public void ${column.setMethodName}(${column.javaType} ${column.attrName}){\n		this.${column.attrName} = ${column.attrName};\n	}\n	\n	public ${column.javaType} ${column.getMethodName}(){\n		return this.${column.attrName};\n	}\n	</#list>\n}\n```\n - modelPackage表示包名，可通过配置文件获取\n - className表示表名\n - 通过list(FreeMarker语法，类似与for循环)生成成员变量、setter/getter方法等信息\n \n## JDBC操作类获取数据库信息\n\n> 模板定义好了，数据库信息和Java内容的对应关系也好了，接下来就是获取数据库信息了。因为我们要做的是一个代码器，所以要尽可能复用，我们可以定义一个JDBC操作类JDBCUtil来操作数据库。\n\n以下是JDBCUtil获取表名和各个表列信息的方法，其余注册数据库驱动、连接数据库写在getConnection()中。\n```java\n	public static List<String> getTables(String database){\n        Connection connection = getConnection();\n        List<String> tables = new ArrayList<>();\n        PreparedStatement pre=null;\n        String sql = \"SELECT table_name FROM information_schema.tables WHERE table_schema = ? \";\n        try {\n            pre = connection.prepareStatement(sql);\n            pre.setObject(1,database);\n            ResultSet res = pre.executeQuery();\n            while(res.next()){\n                tables.add(res.getString(\"table_name\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(\"查询\"+database+\"数据库的数据表失败！\");\n            e.printStackTrace();\n        }finally{\n            try {\n                if(pre!=null)\n                    pre.close();\n                if(connection!=null)\n                    connection.close();\n            } catch (SQLException e) {\n                System.out.println(\"查询\"+database+\"表名后，关闭数据库连接失败！\");\n                e.printStackTrace();\n            }\n        }\n        return tables;\n    }\n\n    public static TableInfo getTableInfo(String database,String tableName){\n        Connection connection = getConnection();\n        TableInfo tableInfo = new TableInfo(tableName);\n        List<ColumnInfo> columnInfos = new ArrayList<>();\n        PreparedStatement pre=null;\n        String sql = \"SELECT COLUMN_NAME,DATA_TYPE,COLUMN_KEY,COLUMN_COMMENT FROM information_schema.COLUMNS T WHERE T.TABLE_SCHEMA=? AND T.TABLE_NAME=?\";\n        try {\n            pre = connection.prepareStatement(sql);\n            pre.setObject(1,database);\n            pre.setObject(2,tableName);\n            ResultSet res = pre.executeQuery();\n            while(res.next()){\n                String columnName = res.getString(\"COLUMN_NAME\");\n                String columnType = res.getString(\"DATA_TYPE\");\n                String comments = res.getString(\"COLUMN_COMMENT\");\n                String pri = res.getString(\"COLUMN_KEY\");\n                ColumnInfo columnInfo = new ColumnInfo(columnName,columnType,comments,pri);\n                columnInfos.add(columnInfo);\n            }\n            tableInfo.setColumnInfos(columnInfos);\n\n        } catch (SQLException e) {\n            System.out.println(\"查询表\"+tableName+\"信息失败！\");\n            e.printStackTrace();\n        }finally{\n            try {\n                if(pre!=null)\n                    pre.close();\n                if(connection!=null)\n                    connection.close();\n            } catch (SQLException e) {\n                System.out.println(\"查询\"+tableName+\"表后，关闭数据库连接失败！\");\n                e.printStackTrace();\n            }\n        }\n        return tableInfo;\n    }\n```\n## 使用FreeMarker生成JavaBean\n\n> 完成了数据模型的获取，模板的定义，最后一步就是生成我们的JavaBean了。\n### 创建Configuration实例\nConfiguration实例是存储FreeMarker应用级设置的核心部分。同时，它也处理创建和缓存预解析模板(比如Template对象)的工作。因为Configuration是单例的，只需创建一次，所以我定义了一个FreemarkerConfiguration来生成。\n\n```java\npublic class FreemarkerConfiguration {\n\n    private static Configuration cfg = null;\n\n    static {\n        try {\n            File resourcesRoot = new File(ResourceConfiguration.getResourceRoot());//ResourceConfiguration.getResourceRoot()是自定义的获取资源文件根目录\n            cfg = new Configuration(Configuration.VERSION_2_3_23);\n            cfg.setDirectoryForTemplateLoading(resourcesRoot);\n            cfg.setDefaultEncoding(\"UTF-8\");\n            cfg.setTemplateExceptionHandler(TemplateExceptionHandler.DEBUG_HANDLER);\n        }catch (IOException ioException){\n            System.out.println(\"freemarker配置初始化失败：无法找到模板存放路径\");\n        }\n    }\n\n    public static Configuration getCfg(){\n        return cfg;\n    }\n}\n```\n### 获取数据模型\n通过前面的准备工作，我们将数据模型信息都放入Map中。\n\n```java\n//获取数据模型，其中blog是博主自己的数据库\npublic Map createModel() throws IOException, TemplateException {\n	List<String> tables = JDBCUtil.getTables(\"blog\");\n    for(int i=0;i<tables.size();i++){\n    	Map root = new HashMap();\n    	TableInfo tableInfo = JDBCUtil.getTableInfo(\"blog\",tables.get(i));\n    	root.put(\"className\", ColumnUtil.getClassName(tables.get(i)));\n        List<ColumnInfo> columnInfos = tableInfo.getColumnInfos();\n        root.put(\"columns\",columnInfos);\n        root.put(\"modelPackage\",\"test\");//自定义包名\n    }\n    return root;\n}\n```\nclassName、columns、数据库名、modelPackage和包名等内容如果需要更加个性化一点，不用硬编码，大家可以将这些内容放在配置文件中，读取配置文件，动态修改，这里暂时先不讲。\n\n### 生成JavaBean\n最后生成JavaBean，如下所示。其中templatePath是模板文件的路径，root是建好的数据模型。\n```java\npublic void writerCode(String templatePath,Map root) throws IOException, TemplateException {\n	//给Configuration实例设置模板路径\n	Template temp = cfg.getTemplate(templatePath);\n	//输出后的文件位置，这里演示设置成控制台窗口，正式用的时候可设置成自己的Java包或文件夹\n    Writer out = new OutputStreamWriter(System.out);\n    //输出内容\n    temp.process(root, out);\n}\n```\n最后效果如下(其中一个表对应的JavaBean)：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210327110444434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTI0MTU3,size_16,color_FFFFFF,t_70)\n\n# 总结\n\n\n大家看过FreeMarker后就知道其实这个Java库上手还是很简单的，很多第三方库都是这样，入门简单，但是如果要将它们用于平时开发中，自己真正能用起来，还是比较麻烦的，主要是细节，比如这次用FreeMarker生成JavaBean，都知道【模板+模型=输出】，但是模板的定义和数据模型的生成中间就有很多细节需要处理，**处理好了就是项目，是自己以后能反复使用的工具，处理不好，就是一次普通demo**。\n## 思路分享\n这次FreeMarker生成JavaBean，我的思路如下：\n\n 1. 首先观察一个bean文件，总结哪些是写死的，哪些需要自己动态补充；\n 2. 然后写一个基本模板；\n 3. 分析模板中的各数据应该如何得到；\n 4. 如何用同一套代码获取同类别的多个数据模型(比如本文中的生成工具类等)；\n 5. 根据模型，修改模板；\n 6. 最后实现。\n\n***\n> 因为时间和篇幅原因，这次只介绍JavaBean的生成，后续将补充Mybatis的mapper接口文件和映射文件等内容的自定义生成，等全部完成之后，会把源码放出来，**有兴趣可以对博主关注，如果平时不怎么看CSDN的关注人动态，可关注下面公众号，不定期分享一些小demo、小项目以及小工具的学习心得**。\n> \n\n![秀宇笔记](https://img-blog.csdnimg.cn/20210327111041466.jpg)\n\n**往期文章：**\n\n - [vue实现markdown编辑器以及md文件转化成html](https://blog.csdn.net/qq_35524157/article/details/114783950)\n - [使用Java生成思维导图](https://blog.csdn.net/qq_35524157/article/details/105882287)\n - [Java实现简易画图板](https://blog.csdn.net/qq_35524157/article/details/82832818)\n - [用Java实现平衡二叉树](https://blog.csdn.net/qq_35524157/article/details/105889182)\n', NULL, 'java,freemarker,生成器,javabean', '', 0, 51, 1, 1, 1, 1, '2021-03-27', '2021-03-27');
INSERT INTO `article` VALUES (3, 'vue实现markdown编辑器以及md文件转化成html', '我们在制作个人的博客系统或类似的项目时，写博客以及将写好的博客展示出来便是绕不开的基本功能，好在目前已有相关的开源插件给开发者使用。', '# 引言\n> 我们在制作个人的博客系统或类似的项目时，写博客以及将写好的博客展示出来便是绕不开的基本功能，好在目前已有相关的开源插件给开发者使用。本文将总结mavon-editor插件和marked插件的使用方法，**通过vue实现markdown编辑器，以及将markdown文件转换成对应的html，并自定义CSS**。\n\n# vue实现markdown编辑器\nmavon-editor是一款基于vue的markdown编辑器，可以帮助开发者快速实现markdown编辑器。下面将介绍基本使用方式。\n\n#### mavon-editor的安装\n\n```javascript\nnpm install mavon-editor --save\n```\n#### mavon-editor的基本使用\n在vue-cli构建脚手架项目的main.js中，引入mavon-editor\n```javascript\n//全局注册基于Vue的markdown编辑器mavon-editor\nimport mavonEditor from \'mavon-editor\'\nimport \'mavon-editor/dist/css/index.css\'\n//使用mavon-editor\nVue.use(mavonEditor)\n```\n在具体html或vue模板中定义挂载点\n    \n```javascript\n<div id=\"main\">\n    <mavon-editor v-model=\"value\"/>\n</div>\n```\n其中value就是绑定的md文本，页面效果如下。\n![效果图](https://img-blog.csdnimg.cn/20210314131603190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTI0MTU3,size_16,color_FFFFFF,t_70)\n其上方的工具栏可通过props中的toolbars自由选择，例如下面编辑器不需要斜体功能，需要粗体功能，默认全部功能开启。\n```javascript\ntoolbars: {\n      bold: true, // 粗体\n      italic: false, // 斜体\n}\n```\nevents事件绑定中，有save的函数，点击工具栏上方的保存按钮时触发事件，我们可以将写好的md文本通过该函数保存到后台。\n\n更详细的使用方式详见官网：[mavon-editor详细使用](https://github.com/hinesboy/mavonEditor/blob/master/README.md)。\n# vue实现将markdown文件转化成html并渲染到浏览器\n#### mavon-editor实现将markdown文件转化成html在浏览器展示\n> 从mavon-editor实现的编辑器效果图可以看到右边有markdown文件的实时预览，可以将其作为转化后的页面，方法如下。（*但是因为本人对前端不是太熟，感觉这种方式不方便自定义样式，所以弃用，有大佬知道这种方式怎么自定义样式可以留言教教我* ）。\n\n在做展示的具体html或vue模板中定义挂载点\n    \n```javascript\n<div id=\"main\">\n       <mavon-editor\n           :value=\"opts.api_doc\"\n           :boxShadow=\"false\"\n           defaultOpen=\"preview\"\n           :toolbarsFlag=\"false\"\n		/>\n</div>\n```\n- 其中subfield为true时，表示编辑预览同屏， 为false时编辑预览分屏)；\n-   defaultOpen为edit时默认展示编辑区域 ，为preview时默认展示预览区域 ；\n-   toolbarsFlag代表工具栏是否显示。\n#### marked.js实现将markdown文件转化成html在浏览器展示\n\n> 最后我选择的是marked.js来解析markdown文件。\n#### marked.js的安装\n\n```javascript\nnpm install marked --save\n```\n#### marked.js的基本使用\n在vue-cli构建脚手架项目的main.js中，引入marked.js\n```javascript\n//全局注册基于Vue的markdown编辑器mavon-editor\nimport marked from ‘marked‘\n```\n在具体html或vue模板中定义挂载点\n\n```javascript\n    <div v-html=\"compiledMarkdown\"></div>\n```\n使用marked函数，即可将md文本转化成html并渲染在浏览器，其中this.input就是md文件，compiledMarkdown 对应页面/模板中的挂载点。\n\n```javascript\ncomputed: {\n	compiledMarkdown : function () {\n		return marked ( this.input)\n	}\n},\n```\n通过marked.setOptions设置渲染参数，如下：\n\n```javascript\n marked.setOptions ({\n        renderer: rendererMD ,\n        gfm: true ,//允许Git Hub标准的markdown.\n        tables: true ,//允许支持表格语法。该选项要求 gfm 为true\n        breaks: false ,//允许回车换行。该选项要求 gfm 为true。\n    })\n```\n详细使用方式及相关api可参考官网：[marked.js详细使用](https://github.com/markedjs/marked)，其中的Docs标题下的链接有介绍。\n\n一份md文件解析后在浏览器效果如下(*md文件来源于以前的博客*)：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210314135632712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTI0MTU3,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210314135649497.png)\n# 自定义CSS样式\n\n> 从上面的效果图可以看出其中的代码、文字和链接等都是最基本的html样式，对代码而言，我们可以引入highlight.js实现代码的高亮。\n\n#### highlight.js实现代码高亮\n```javascript\nnpm install highlight.js --save//安装\nimport hljs from \'highlight.js\'//引用\nimport \"highlight.js/styles/monokai-sublime.css\"; // 引入高亮样式 这里我用的是sublime样式\n```\n在marked.setOptions中加上：\n\n```javascript\nhighlight: function(code) {\n	return hljs.highlightAuto(code).value;\n},\n```\n最终代码效果如下。明显可以看出代码不再是纯黑字了，代码、关键字、注释等都有不同颜色和亮度，高亮样式有很多种，我这种是sublime样式，具体可以参考[highlight.js中文网](https://fenxianglu.cn/highlight.html?theme=androidstudio)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210314141116345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTI0MTU3,size_16,color_FFFFFF,t_70)\n#### 给标题、文本、表格等自定义CSS样式\n\n> 对于普通文本、表格、序列和链接等，我们可以设置自己的样式。\n\n只需要再挂载的div上加上class即可。\n\n```javascript\n//mymarkdown-body就是对应的class选择器\n<div class=\"mymarkdown-body\" v-html= \"compiledMarkdown\"></div>\n```\n比如一个#对应的html标签是< h1 >，那么我们只需要对h1定义一下样式即可，比如我在mymarkdown-body.css文件中定义h1的字体大小为100px。\n```css\n.mymarkdown-body h1 {\n    font-size: 100px\n}\n.mymarkdown-body blockquote {\n    display: block;\n    margin: 0 0 12px;\n    border-left: 8px solid #dddfe4;\n    background: #eef0f4;\n    overflow: auto;\n}\n.mymarkdown-body a {\n    color: #4ea1db;\n    text-decoration: none;\n}\n```\n最后h1标题的文字效果就变成了下图。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210314142315654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTI0MTU3,size_16,color_FFFFFF,t_70)\nblockquote 和a对应的是引用块和链接的样式，是不是跟CSDN解析出来的差不多？\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210314142819459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTI0MTU3,size_16,color_FFFFFF,t_70)\n同样的，我们可以对其他的标签样式进行修改，毕竟常用的markdown语法并不是太多。可能很多人觉得慢慢调试样式很麻烦，这里我用的一个方式是，找到一个差不多的网页，比如博客的话，找CSDN，打开一篇文章，按F12，就可以看到对应文本的CSS样式，然后把它复制过来，稍微改改就行了。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210314142726826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTI0MTU3,size_16,color_FFFFFF,t_70)\n# (待补充)官方样式\n> 如果不自定义样式，marked.js和mavon-editor也都有自带的样式，大家可以在官方文档当中选择使用，我原本也有个官方样式的demo，找不到了，就不介绍了╮(╯▽╰)╭，大家可以在官网自行了解，如果哪天我再做的时候补充吧~~\n', 'defaults', 'vue,个人博客', '', 3, 178, 1, 1, 1, 1, '2021-05-20', '2021-05-20');
INSERT INTO `article` VALUES (4, 'idea2020.1踩坑：找不到程序包和符号(冷门解决)', '我下好idea2020.1和maven之后，在maven的setting.xml加上了localRepository修改仓库位置，然后在idea的setting里面设置maven地址为我修改到的那个地址', '# idea2020.1踩坑：找不到程序包和符号(冷门解决)\n我下好idea2020.1和maven之后，在maven的setting.xml加上了localRepository修改仓库位置，然后在idea的setting里面设置maven地址为我修改到的那个地址(**这也是我以前在多台电脑上的做法，都没有出现过现在这种情况**)。\n\n在使用idea2020.1版本创建maven项目编译时提示找不到程序包和符号之类的错误。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200430184847545.png)\n\n我试了网上很多解决办法，包括重新编译、设置编码、检查版本、检查maven等等。因为这些解决方式网上很多，我就不写了，可以见下面这个博主的博文(写的时候随手找的，基本上就这些方式)。\n\n> [idea找不到程序包和符号常见的解决方式](https://www.cnblogs.com/yswyzh/p/9808878.html)\n\n上面这些方法我都试过，都没能解决，因为idea是破解的，所以一度怀疑是不是破解jar包的问题，或者是新版idea在防盗版上又做了什么设计。\n\n后来问了下我一位用了同版本idea，同一个破解jar包的朋友，发现他的没问题，但是他的maven仓库是默认的，在C盘，因此我想是不是这个原因。\n\n我把idea的maven设置还原成默认的，然后再跑，终于成功了，但jar下在C盘也不是办法，后来百度翻了七八页才翻到跟我有同样问题的兄弟(说明这种情况可能确实少，搜半天才一篇)，**要把maven自己加的localRepository删掉，用默认的，如果不想下在C盘，就在idea手动修改本地仓库的配置。**\n\n到此终于解决了找不到程序包和符号的问题，也解决了默认仓库占用系统盘的问题。至于原因，暂时不知道，以前都是修改maven的setting.xml添加localRepository，然后idea直接就用了，这次idea2020.1为什么不能就不清楚了。\n\n我本来是懒得写这种博文的，而且这种情况很多博客都写了，但是这种解决方法确实不多，像我，翻了好几页，换了无数种关键词搜索才找到一篇，所以我才写这篇博文，希望对遇到同样问题的人有所帮助。\n***\n> **有兴趣可以对博主关注，如果平时不怎么看CSDN的关注人动态，可关注下面公众号，不定期分享一些小demo、小项目以及小工具的学习心得**。\n\n> ![秀宇笔记](https://img-blog.csdnimg.cn/20210327111041466.jpg)\n\n**推荐文章：**\n\n - [基于FreeMarker的自定义代码生成器](https://blog.csdn.net/qq_35524157/article/details/115260135)\n - [vue实现markdown编辑器以及md文件转化成html](https://blog.csdn.net/qq_35524157/article/details/114783950)\n - [使用Java生成思维导图](https://blog.csdn.net/qq_35524157/article/details/105882287)\n - [Java实现简易画图板](https://blog.csdn.net/qq_35524157/article/details/82832818)\n - [用Java实现平衡二叉树](https://blog.csdn.net/qq_35524157/article/details/105889182)\n', 'defaults', 'Java,maven,idea,编辑器', '', 201, 21186, 1, 1, 1, 1, '2021-05-20', '2021-05-20');
INSERT INTO `article` VALUES (5, '使用Java生成思维导图', '最近因为一些原因需要做一些资料管理，准备建一个文件夹，然后对各种资料做一个分类，每个分类做一个文件夹。可以想象，随着资料数量和种类的增多，文件层级关系的增加', '# 使用Java生成思维导图\n### 前言\n最近因为一些原因需要做一些资料管理，准备建一个文件夹，然后对各种资料做一个分类，每个分类做一个文件夹。\n\n可以想象，随着资料数量和种类的增多，文件层级关系的增加，以后需要查一个文件在哪个位置的时候可能就不那么方便，Windows的资源管理器搜索在文件多的时候又不是很快，因此决定做一个资源地图，能够把所有的文件和文件夹以一种**树状图的方式展示出来**，首先想到的就是xmind了。\n\nxmind是我们日常工作学习中常用的思维导图工具之一。如果每次对文件的增删改查都对xmind文件做出相应的修改，那效率也太差了，而且也容易出错，好在官方提供了Java api来生成xmind文件，这样每次只要运行程序就可以自动生成最新的资源地图了。\n\n\n### xmind依赖\nxmind在github的仓库位置可以见文章末的链接。对xmind操作的api全在org.xmind.core包下，按照官方的使用说明把代码拉下来打个包引入就可以了，也可以引入maven依赖。\n - pom.xml\n```java\n<dependency>\n  <groupId>com.github.eljah</groupId>\n  <artifactId>xmindjbehaveplugin</artifactId>\n  <version>0.8</version>\n</dependency>\n```\n### 数据准备\n要生成思维导图，首先要有数据，比如说我这里的数据就是某个目录底下的所有文件夹和文件，并且将他们按照包含或并列关系用合适的方式存储好。\n\n我用一个自定义的数据结构储存文件(夹)信息。\n\n```java\npublic class FileNode {\n    private String fileName;//文件名\n    private ArrayList<FileNode> subFiles;//如果是文件，则值为null，如果是文件夹，则每个元素代表该文件夹下的文件(夹)名\n\n    public FileNode(String fileName){\n        this.fileName=fileName;\n        this.subFiles=null;\n    }\n\n    public String getFileName() {\n        return fileName;\n    }\n\n    public ArrayList<FileNode> getSubFiles() {\n        return subFiles;\n    }\n\n    public void setSubFiles(ArrayList<FileNode> subFiles) {\n        this.subFiles = subFiles;\n    }\n}\n```\n定义好了数据的存储方式，然后定义获取文件列表的方法。\n\n```java\n//获取path目录下的所有文件名\npublic ArrayList<String> getFiles(String path){\n    ArrayList<String> files = new ArrayList<>();\n    File file = new File(path);\n    File[] tempList = file.listFiles();\n\n    for(int i=0;i<tempList.length;i++){\n        if(tempList[i].isFile()){\n            files.add(tempList[i].toString());\n        }\n    }\n\n    return files;\n}\n//获取path目录下的所有文件夹名\npublic ArrayList<String> getFolder(String path){\n    ArrayList<String> directorys = new ArrayList<>();\n    File file = new File(path);\n    File[] tempList = file.listFiles();\n\n    for(int i=0;i<tempList.length;i++){\n        if(tempList[i].isDirectory()){\n            directorys.add(tempList[i].toString());\n        }\n    }\n\n    return directorys;\n}\n//将path目录下的所有文件(夹)根据它们的关系处理成存储节点，并返回根节点\npublic FileNode getAll(String path){\n    FileNode root = new FileNode(path);\n    ArrayList<FileNode> subfiles = new ArrayList<>();\n    ArrayList<String> folders = getFolder(path);\n    ArrayList<String> files = getFiles(path);\n\n    for(String tempPath : folders){\n        if(tempPath.endsWith(\".svn\"))\n            continue;\n        FileNode folder = getAll(tempPath);\n        subfiles.add(folder);\n    }\n\n    for(String tempFile : files){\n        FileNode file = new FileNode(tempFile);\n        subfiles.add(file);\n    }\n    root.setSubFiles(subfiles);\n\n    return root;\n}\n```\n通过以上程序便完成了对需要画成思维导图的数据的处理。\n\n### 生成xmind\n平时使用xmind画时，首先要新建一个工作空间，得到一个没有任何节点的空白导图，然后在这个工作空间得到一个sheet，类似于excel表格的sheet。通过代码生成的方式如下。\n\n```java\n// 创建思维导图的工作空间\nIWorkbookBuilder workbookBuilder = Core.getWorkbookBuilder();\nIWorkbook workspace= workbookBuilder.createWorkbook();\n// 获得默认sheet\nISheet primarySheet = workspace.getPrimarySheet();\n```\n这样我们便可以在工作空间上创建节点了，对于每一个节点，我们可以用下面代码生成。\n\n```java\n//生成一个节点\nITopic topic = workspace.createTopic();\n//设置节点名称(name在我这里表示文件或文件夹的名字)\ntopic.setTitleText(name);\n```\n生成多个节点之后，我们怎么设置节点之间的关系呢？\n\n```java\ntopic.add(subTopic,ITopic.ATTACHED);\n```\n上面这行代码就是将subTopic的节点添加到topic节点上，**即subTopic是topic目录下的文件(夹)**。\n\n最后把第一级的节点，在我的程序里就是我的文件根目录的节点，设置为思维导图的根节点。\n\n```java\n// 获得根主题节点\nITopic rootTopic = primarySheet.getRootTopic();\n// 设置根主题的标题\nrootTopic.setTitleText(bookName);\n\n//由于我已经得到了根目录的节点，所以只需要替换sheet的根节点，而不需要调用getRootTopic\nprimarySheet.replaceRootTopic(rootTopic);\n```\n最后通过workspace的save方法把文件保存，文件后缀需要保存为“.xmind”，否则软件无法识别。\n\n打开xmind文件之后，效果如下：\n\n![结果示意图](https://img-blog.csdnimg.cn/20200501220242355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTI0MTU3,size_16,color_FFFFFF,t_70#pic_center)\n\n\n### 总结\n因为篇幅有限，如果需要我的完整代码作为参考例子，可以访问github地址：**基于xmind api的资源地图小工具**\n> [xmind 官方 github地址](https://github.com/xmindltd/xmind/wiki/UsingXmindAPI)\n> [基于xmind api的资源地图小工具](https://github.com/linovce/Java-Applications)\n\n文章主要以如何根据文件目录结构来通过Java画思维导图做使用xmind api的例子，但是也可以拓展到其他内容，只要得到数据的层级关系，便可以通过xmind api画出对应的思维导图，例如书的目录等等，根据实际情况来就行了。\n', 'defaults', 'Java,经验分享,程序人生,思维导图,xmind', '', 17, 1592, 1, 1, 1, 1, '2021-05-20', '2021-05-20');
INSERT INTO `article` VALUES (6, '用Java实现平衡二叉树', '根据上述定义可知二叉排序树的中序遍历是一个递增的有序序列。但是二叉排序树的平均查找长度与二叉树的形态有关，如果二叉排序树是一个只有左(右)孩子的单支树，则其平均查找长度与单链表无异，因此我们为了避免书的高度增长过快', '### ​平衡二叉树的定义\n\n在谈平衡二叉树之前，首先了解一下二叉排序树。空树或者具有以下特性的二叉树就是二叉排序树：\n 1. 若左子树非空，则左子树上所有结点关键字的值均小于根节点的关键字的值。\n 2. 若右子树非空，则右子树上所有结点关键字的值均大于根节点的关键字的值。\n 3.  左右子树本身也分别是一棵二叉排序树。\n \n根据上述定义可知二叉排序树的中序遍历是一个递增的有序序列。但是二叉排序树的平均查找长度与二叉树的形态有关，如果二叉排序树是一个只有左(右)孩子的单支树，则其平均查找长度与单链表无异，因此我们为了避免书的高度增长过快，降低二叉排序树的性能，定义了平衡二叉树。\n\n若二叉排序树的左右子树的高度只差的绝对值不超过1，则这样的二叉排序树称为**平衡二叉树(AVL)**。左右子树的高度差称作**平衡因子**，所以平衡二叉树的平衡因子的值只能是-1、0或1。\n\n### 平衡二叉树的插入\n为了让二叉排序树在每一次插入和删除新结点时都使树保持平衡，所以每次操作之后都要对树的结构进行调整，其**基本思想**是：\n\n> 当在二叉排序树中插入或删除一个结点时，首先检查其插入路径上的结点是否因为此次操作导致了不平衡，若导致了不平衡，则先找到插入路径上离插入节点最近的平衡因子的绝对值大于1的结点A，再对以A为跟的子树，在保持二叉排序树特性的前提下，调整结点位置使之重新平衡。\n\n其插入过程前半部分是二叉排序树的插入过程，但在新结点插入后，若造成某结点不平衡，则需要做出调整，一般可将失去平衡后进行调整的规律归纳为下列四种情况。\n\n - LL平衡旋转(右单旋转)：在结点A的左孩子的左子树上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要一次向右的旋转。将A的左孩子B向右上旋转代替A成为根节点，将A结点向右下旋转称为B的右子树的根节点，而B的原右子树作为A结点的左子树。如下图所示，结点旁的数字表示平衡因子，方块是对应子树，H表示子树高度。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200502124516888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTI0MTU3,size_16,color_FFFFFF,t_70)\n - RR平衡旋转(左单旋转)：在结点A的右孩子的右子树上插入新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要一次向右的旋转。将A的右孩子B向左上旋转代替A称为根节点，将A结点向左下旋转称为B的左子树的根结点，而B的原左子树则作为A结点的右子树。\n\n\n   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200502124535930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTI0MTU3,size_16,color_FFFFFF,t_70)\n\n - LR平衡旋转(先左后右双旋转)：在结点A的左孩子的右子树上掺入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先向左旋转后向右旋转。先将A结点的左孩子B的右子树的根节点C向左上旋转提升到B结点的位置，然后再把C结点向右上旋转提升到A结点。\n \n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200502124549326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTI0MTU3,size_16,color_FFFFFF,t_70)\n\n- RL平衡旋转(先右后左双旋转)：在结点A的右孩子的左子树上插入新结点，A的平衡因子由-1减至-2，导致以A为跟的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。先将A结点的右孩子B的左子树的根节点C向右上旋转提升至B结点的位置，然后再把该C结点向左上旋转提升到A结点的位置。\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200502124606121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTI0MTU3,size_16,color_FFFFFF,t_70)\n\n\n### 平衡二叉树的实现\n弄清了如何使平衡二叉树保持平衡的原理，那么便可以用代码实现，从上述四种情况来看，实现的难点在于旋转，只要把旋转弄清楚，基本上整个树就能完成。\n\n首先我们需要定义一个树的结点。\n\n```java\npublic class Node {\n    public Node parent;//指向父节点\n    public Node left;//指向左子树\n    public Node right;//指向右子树\n    public int data;//节点数据\n    public int depth;//节点深度\n    public int balance;//是否平衡\n    public Node(int data){\n        this.data=data;\n        depth=1;\n        balance=0;\n        left=null;\n        right=null;\n        parent=null;\n    }\n}\n```\n\n从平衡二叉树的特性来看，我们需要知道平衡二叉树的平衡因子。\n\n```java\npublic int calcBalance(Node p) {\n    int left_depth;\n    int right_depth;\n    //左子树的深度\n    if(p.left != null){\n        left_depth = p.left.depth;\n    }else{\n        left_depth = 0;\n    }\n    //右子树的深度\n    if(p.right != null){\n        right_depth = p.right.depth;\n    }else{\n        right_depth = 0;\n    }\n\n    return left_depth-right_depth;\n}\n```\n\n平衡因子又是根据左右子树的高度来的，因此，我们需要计算高度。\n\n```java\npublic int calcDepth(Node p) {\n    int depth = 0;\n    if(p.left != null){\n        depth = p.left.depth;\n    }\n    if(p.right != null && depth < p.right.depth){\n        depth = p.right.depth;\n    }\n\n    depth++;\n    return depth;\n}\n```\n\n右旋操作涉及到祖父结点、父结点和右子结点。\n\n```java\npublic void right_rotate(Node p) {\n    Node pParent = p.parent;\n    Node pLeftSon = p.left;\n    Node pRightGrandSon = pLeftSon.right;\n    pLeftSon.parent = pParent;\n    if(pParent != null){\n        if(p == pParent.left){\n            pParent.left = pLeftSon;\n        }else if(p == pParent.right){\n            pParent.right = pLeftSon;\n        }\n    }\n\n    pLeftSon.right = p;\n    p.parent = pLeftSon;\n    \n    p.left = pRightGrandSon;\n    if(pRightGrandSon != null){\n        pRightGrandSon.parent = p;\n    }\n\n    p.depth = calcDepth(p);\n    p.balance = calcBalance(p);\n    pLeftSon.depth = calcDepth(pLeftSon);\n    pLeftSon.balance = calcBalance(pLeftSon);\n}\n```\n\n左旋操作涉及到祖父结点、父结点和左子结点。\n\n```java\npublic void left_rotate(Node p) {\n    Node pParent = p.parent;\n    Node pRightSon = p.right;\n    Node pLeftGrandSon = pRightSon.left;\n    \n    pRightSon.parent = pParent;\n    if(pParent != null){\n        if(p == pParent.right){\n            pParent.right = pRightSon;\n        }else if(p == pParent.left){\n            pParent.left = pRightSon;\n        }\n    }\n\n    pRightSon.left = p;\n    p.parent = pRightSon;\n    p.right = pLeftGrandSon;\n    if(pLeftGrandSon != null){\n        pLeftGrandSon.parent = p;\n    }\n\n    p.depth = calcDepth(p);\n    p.balance = calcBalance(p);\n    pRightSon.depth = calcDepth(pRightSon);\n    pRightSon.balance = calcBalance(pRightSon);\n}\n```\n\n然后便是数据的插入。\n\n```java\npublic void insert(Node root, int data){\n    //数据小于根结点，左递归插入\n    if(data < root.data){\n        if(root.left != null){\n            insert(root.left, data);\n        }else{\n            root.left = new Node(data);\n            root.left.parent=root;\n        }\n    }else{//数据大于根结点，右递归插入\n        if(root.right != null){\n            insert(root.right, data);\n        }else{\n            root.right = new Node(data);\n            root.right.parent = root;\n        }\n    }\n    //插入之后计算平衡因子\n    root.balance = calcBalance(root);\n    //左子树高则右旋\n    if(root.balance >= 2){\n        //右孙高先左旋\n        if(root.left.balance == -1){\n            left_rotate(root.left);\n        }\n        right_rotate(root);\n    }\n    //右子树高则左旋\n    if(root.balance <= -2){\n        //左孙高则先右旋\n        if(root.right.balance == 1){\n            right_rotate(root.right);\n        }\n        left_rotate(root);\n    }\n    //调整之后重新计算平衡因子和树的高度\n    root.balance = calcBalance(root);\n    root.depth = calcDepth(root);\n}\n```\n\n以上便是平衡二叉树的插入思想和代码实现，欢迎大家交流！\n\n', 'defaults', '数据结构,算法,Java,二叉树,平衡二叉树', '', 3, 398, 1, 1, 1, 1, '2021-05-20', '2021-05-20');

-- ----------------------------
-- Table structure for classification
-- ----------------------------
DROP TABLE IF EXISTS `classification`;
CREATE TABLE `classification`  (
  `classification_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '分类id',
  `classification_name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '分类名',
  PRIMARY KEY (`classification_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `comment_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '评论id',
  `article_id` int(11) NULL DEFAULT NULL COMMENT '文章id',
  `reply_comment_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '子评论id',
  `is_parent` int(11) NULL DEFAULT NULL COMMENT '是否是根评论',
  `comment_detail` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '评论内容',
  `user_name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '昵称',
  `user_email` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '邮箱',
  `appreciate` int(11) NULL DEFAULT NULL COMMENT '点赞',
  `create_date` date NULL DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`comment_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for label
-- ----------------------------
DROP TABLE IF EXISTS `label`;
CREATE TABLE `label`  (
  `label_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '标签id',
  `label_name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '标签名',
  PRIMARY KEY (`label_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for menu
-- ----------------------------
DROP TABLE IF EXISTS `menu`;
CREATE TABLE `menu`  (
  `menu_id` int(11) NOT NULL COMMENT '菜单ID',
  `menu_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '菜单名',
  `menu_url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '菜单url',
  `parent_id` int(11) NULL DEFAULT NULL COMMENT '父菜单ID',
  `create_date` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `done_date` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`menu_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for power
-- ----------------------------
DROP TABLE IF EXISTS `power`;
CREATE TABLE `power`  (
  `power_id` int(11) NOT NULL COMMENT '权限ID',
  `power_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '权限名',
  `power_type` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '权限类型(1菜单、2页面元素、3文件、0其他)',
  `create_date` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `done_date` datetime(0) NULL DEFAULT NULL COMMENT '操作时间',
  PRIMARY KEY (`power_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for role
-- ----------------------------
DROP TABLE IF EXISTS `role`;
CREATE TABLE `role`  (
  `role_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '角色ID',
  `role_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '角色名',
  `create_date` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `done_date` datetime(0) NULL DEFAULT NULL COMMENT '操作时间',
  PRIMARY KEY (`role_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for role_power
-- ----------------------------
DROP TABLE IF EXISTS `role_power`;
CREATE TABLE `role_power`  (
  `role_power_id` int(11) NOT NULL COMMENT '角色权限ID',
  `power_id` int(11) NULL DEFAULT NULL COMMENT '权限ID',
  `role_id` int(11) NULL DEFAULT NULL COMMENT '角色ID',
  `create_date` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `done_date` datetime(0) NULL DEFAULT NULL COMMENT '操作时间',
  PRIMARY KEY (`role_power_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `user_id` int(11) NOT NULL COMMENT '用户id',
  `user_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '用户名',
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '密码',
  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '邮箱',
  `type` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '用户类型',
  `create_date` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `done_date` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`user_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for user_role
-- ----------------------------
DROP TABLE IF EXISTS `user_role`;
CREATE TABLE `user_role`  (
  `user_role_id` int(11) NOT NULL COMMENT '用户角色ID',
  `user_id` int(11) NULL DEFAULT NULL COMMENT '用户ID',
  `role_id` int(11) NULL DEFAULT NULL COMMENT '角色ID',
  `create_date` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `done_date` datetime(0) NULL DEFAULT NULL COMMENT '操作时间',
  PRIMARY KEY (`user_role_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

SET FOREIGN_KEY_CHECKS = 1;
